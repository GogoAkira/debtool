#!/bin/bash
#
# Simple tool to facilitate downloading and repacking debian archives


# create a debian archive from a directory
build(){

    if [[ -d $1 ]]; then
        prep "$1"

        if [[ -n $2 ]]; then
            archive=$2
        else

            # identify archive control file
            control=$1/DEBIAN/control

            # confirm existence of archive control
            if [[ ! -f $control || ! -r $control || ! -s $control ]]; then
                error "'$1' is missing control file"
                exit 1
            fi

            # determine archive name from contents of control file
            archive=$(awk '/^Package: / { p=$2 }; /^Version: / { v=$2 }; /^Architecture: / { a=$2 }; END{ if ( length(a) > 0 ) { printf "%s_%s_%s.deb", p, v, a } else { printf "%s_%s.deb", p, v } }' "$control")

        fi

        check_build_destination "$1" "$archive"

        # build the archive
        # fakeroot dpkg-deb --build "${1%/}" "$archive"
        fakeroot dpkg-deb --build "$1" "$archive"

        # check if build failed
        if (( $? != 0 )); then
            error "dpkg-deb exited with a nonzero exit code"
            restore_backup
            exit 1
        fi

        # check if archive was created and handle backup
        if [[ -f $archive ]]; then
            remove_backup
        else
            restore_backup
            exit 1
        fi

        if [[ $reinstall = 'true' ]]; then
            reinst "$archive"
        fi
    else
        if [[ -n $1 ]]; then
            error "'$1' is not a directory"
        else
            error "You have not supplied a directory"
        fi
        exit 1
    fi

}

# ensure build destination does not already exist
check_build_destination(){
    if [[ -e $2 && -f $2 ]]; then
        if [[ $auto != enabled ]]; then

            # prompt to overwrite pre-existing file
            read -p "Overwrite pre-existing file '$2'? "
            if [[ ${REPLY,} != y* ]]; then
                exit 1
            fi

        else
            warning "Overwriting pre-existing file '$2'"
        fi

        create_backup "$@"

    elif [[ -e $2 ]]; then
        error "Unable to build '$1' (destination '$2' already exists but is not a file)"
        exit 1
    fi
}

# ensure unpack destination does not already exist
check_unpack_destination(){
    if [[ -e $2 ]]; then
        error "Unable to unpack '$1' (destination folder '$2' already exists)"
        exit 1
    fi
}

# download package(s) via apt-get then unpack
combo(){

    for package in "$@"; do

        # aquire the package destination filename

        # NOTE: apt-get will output nothing if package exists in the
        #       current directory, hence the need to cd out if. This
        #       is quite hackish but the alternative would be manually
        #       parsing `apt-cache show "$package"`.

        local dest=$(cd / && apt-get --print-uris download "$package" 2>/dev/null | awk '{print $2}')

        # confirm apt-get was able to determing package destination filename
        if (( $? != 0 )) || [[ -z $dest ]]; then
            error "Failed to identify '$package' for download"
            continue
        fi

        # store apt-get output log to determing if download occurred

        # NOTE: We are using apt-get to download even if $dest already
        #       exists because apt-get is intelligent and will only
        #       re-download if neccesary (i.e. file checksum mismatch).

        local output=$(apt-get --quiet download "$package" 2>/dev/null)

        # confirm apt-get exited successfully
        if (( $? != 0 )); then
            error "apt-get experienced an error downloading '$package'"
            continue
        # confirm download exists
        elif [[ ! -f $dest ]]; then
            error "Failed to download '$package'"
            continue
        fi

        # unpack downloaded archive
        if [[ -n $output ]]; then
            unpack "$dest"
        # prompt to unpack pre-existing archive (if auto is not enabled)
        elif [[ $auto != enabled ]]; then
            read -p "Would you like to unpack pre-existing archive '$dest'? "
            if [[ ${REPLY,} = y* ]]; then
                unpack "$dest"
            fi
        # skip prompt (if auto is enabled)
        else
            echo "Skipping unpack of pre-existing archive '$dest'"
        fi

    done

}

# backup a pre-existing archive (into a temp dir)
create_backup(){

    # create a temporary directory
    tempdir=$(mktemp --directory 2>/dev/null)
    if [[ ! -d $tempdir ]]; then
        error "Experienced unknown error while creating temporary directory"
        echo "Please remove the pre-existing file and try again"
        exit 1
    fi

    # backup pre-existing file
    mv "$2" "$tempdir"
    if [[ -f "$tempdir/${2##*/}" ]]; then
        backup="$tempdir/${2##*/}"
        info "Created backup of '$2' at '$backup'"
    else
        info "Failed to backup '$2'"
    fi

}

# # backup a pre-existing archive (into the same dir)
# create_backup(){
#     if [[ ! -e "${2}~" ]]; then
#         mv "$2" "${2}~"
#         if [[ -f "${2}~" ]]; then
#             info "Created backup of '$2'"
#             backup='true'
#         else
#             info "Failed to backup '$2'"
#             error "Please remove '$2' before retrying"
#             exit 1
#         fi
#     fi
# }

# download package(s) via apt-get
download(){

    local successes
    local failures

    for package in "$@"; do
        if apt-get download "$package" &>/dev/null; then
            successes+=("$package")
        else
            failures+=("$package")
        fi
    done

    if (( ${#successes[@]} > 0 )); then
        echo "Successfully downloaded: ${successes[@]}"
    fi

    if (( ${#failures[@]} > 0 )); then
        echo "Failed to download: ${failures[@]}"
        exit 1
    fi
}

error(){
    echo "${script}:ERROR: $@" >&2
}

info(){
    echo "${script}:INFO: $@"
}

# determing package type (archive, installation, neither, or both)
pkgtype(){
    local pkgtype=()

    # for a debian archive file
    dpkg-deb --info "$1" &>/dev/null && pkgtype+=(archive)

    # for an installed package
    dpkg-query --show --showformat='${Status}' "$1" 2>/dev/null | grep -Fq 'install ok installed' && pkgtype+=(installation)

    if (( ${#pkgtype[@]} == 0 )); then
        error "'$1' is not an installed package or valid debian archive"
        return 1
    elif (( ${#pkgtype[@]} == 1 )); then
        echo "${pkgtype[0]}"
    elif (( ${#pkgtype[@]} == 2 )); then
        warning "'$1' is both an installed package and a debian archive (assuming you are referring to the debian archive)"
        echo archive
    fi
}

# prepare directory prior to build
prep(){
    (

        # enter directory
        cd "$1"

        # prepare manpages (verify write access, set perms, compress)
        while IFS= read -rd $'\0' manpage; do
            if [[ ! -w $manpage ]]; then
                error "No write access to '$manpage'"
                return 1
            elif ! chmod 0644 "$manpage"; then
                error "Failed to chmod '$manpage'"
                return 1
            elif ! gzip -9fn "$manpage" ; then
                error "Failed to gzip '$manpage'"
                return 1
            fi
        done < <(find -type f -regex '\./usr/share/man/.*' -name '*.[1-9]' ! -name '*.gz' -print0)

        # update md5sums if necessary
        if [[ -f DEBIAN/md5sums ]]; then

            # verify write access
            if [[ ! -w DEBIAN/md5sums ]]; then
                error "No write access to 'DEBIAN/md5sums'"
                return 1
            elif ! prep_md5sums; then
                error "Failed to update DEBIAN/md5sums"
                return 1
            elif ! md5sum --check --status DEBIAN/md5sums; then
                error "DEBIAN/md5sums failed checksum verification"
                return 1
            fi

        fi

    ) || exit 1
}

# remake md5sums using original as a template
prep_md5sums(){
    mv "DEBIAN/md5sums" "DEBIAN/md5sums~" &&
    awk '{printf "%s\0", $2}' "DEBIAN/md5sums~" \
    | xargs -0r md5sum > DEBIAN/md5sums &&
    rm "DEBIAN/md5sums~" &&
    chmod 644 "DEBIAN/md5sums"
}

# reinstall package(s)
reinst(){

    for archive in "$@"; do

        # confirm archive is a file
        if [[ ! -f $archive ]]; then
            error "'$archive' does not appear to be a valid file"
            continue
        fi

        # lookup package name in archive control file
        package=$(dpkg-deb -f "$archive" package 2>/dev/null)

        # confirm lookup of package name was successful
        if [[ -z $package ]]; then
            error "'$archive' does not appear to be a valid debian archive"
            continue
        fi

        # if sudo apt-get purge "$package" &>/dev/null; then
        if sudo dpkg --purge "$package" &>/dev/null; then
            echo "dpkg: purged '$package'"
        else
            echo "dpkg: failed to purge '$package' (perhaps it was not installed)"
        fi

        if sudo dpkg --install "$archive" &>/dev/null; then
            echo "dpkg: installed '$package' ($archive)"
        else
            echo "dpkg: failed to install '$package' ($archive)"
        fi

    done

}

# remove an archive backup (from a temp dir)
remove_backup(){
    if [[ -n $backup ]]; then
        rm "$backup"
        rmdir "$tempdir"
    fi
}

# # remove an archive backup (from the same dir)
# remove_backup(){
#     if [[ -f "${archive}~" && $backup = 'true' ]]; then
#         rm "${archive}~"
#         if [[ -f "${archive}~" ]]; then
#             info "Failed to remove backup file '${archive}~'"
#         else
#             info "Removed backup file '${archive}~'"
#         fi
#     fi
# }

# restore an archive backup (from a temp dir)
restore_backup(){
    if [[ -n $backup ]]; then
        mv -T "$backup" "$archive"
        if [[ -f $archive ]]; then
            info "Restored '$archive' from backup"
        else
            info "Failed to restore '$archive' from backup"
        fi
        rmdir "$tempdir"
    fi
}

# restore an archived backup (from the same dir)
# restore_backup(){
#     if [[ -f "${archive}~" && $backup = 'true' ]]; then
#         mv "${archive}~" "$archive"
#         if [[ -f $archive ]]; then
#             info "Restored '$archive' from backup"
#         else
#             info "Failed to restore '$archive' from backup"
#         fi
#     fi
# }

# show packages available for download
show(){

    for package in "$@"; do

        if [[ $format = enabled ]]; then
            printstr='printf "apt-get download %s=%s -a=%s\n", p, v, a'
        else
            printstr='print p, v, a'
        fi

        results=$(apt-cache show "$package" 2>/dev/null | awk "/^Package: /{p=\$2} /^Version: /{v=\$2} /^Architecture/{a=\$2} /^$/{ $printstr }")

        if (( $? != 0 )) || [[ -z $results ]]; then
            error "apt-cache is unable to locate package '$package'"
            continue
        else
            echo "$results"
        fi

    done
}

# unpack a debian archive or installed package
unpack(){

    # determine package type (debian archive or installed) and exit if neither
    pkgtype=$(pkgtype "$1") || exit 1

    if [[ $pkgtype = archive ]]; then
        if [[ -n $2 ]]; then
            local target=$2
        else
            local target=$(dpkg-deb --field "$1" package version architecture | awk '{print $2}' | paste -sd_)
        fi

        check_unpack_destination "$1" "$target"

        # unpack archive
        dpkg-deb --raw-extract "$1" "$target"
    elif [[ $pkgtype = installation ]]; then
        if [[ -n $2 ]]; then
            local target=$2
        else
            local target=$1
        fi

        check_unpack_destination "$1" "$target"

        # unpack into tmpfolder
        local tmpfolder=$(fakeroot -u dpkg-repack --generate "$1" 2>/dev/null | awk '{print $(NF-2)}')

        # rename tmpfolder to target then clean up control file modified by dpkg-repack
        mv "$tmpfolder" "$target" &>/dev/null \
        && sed -i 's/ .$//;/ (Repackaged on .* by dpkg-repack.)/d' "$target/DEBIAN/control" &>/dev/null
    fi

    # check for target directory and exit now if missing
    if [[ ! -d $target ]]; then
        error "Failed to generate folder '$target' for '$1'"
        exit 1
    fi

    echo "Successfully unpacked $pkgtype to: $target"

    # prompt to delete archive
    if [[ $pkgtype = archive && $auto != enabled ]]; then
        read -p "Remove '$1'? "
        if [[ ${REPLY,} = y* ]]; then
            rm "$1"
        fi
    fi
}

# # unpack a debian archive or installed package
# unpack(){
#     # for a debian archive file
#     if dpkg-deb --info "$1" &>/dev/null; then
#         local pkgtype=archive
#         if [[ -n $2 ]]; then
#             local target=$2
#         else
#             local target=$(dpkg-deb --field "$1" package version architecture | awk '{print $2}' | paste -sd_)
#         fi

#         if [[ -e $target ]]; then
#             error "Unable to unpack '$1' (destination already exists)."
#             exit 1
#         fi

#         # unpack archive
#         dpkg-deb --raw-extract "$1" "$target"

#     # for an installed package
#     elif dpkg-query --show --showformat='${Status}' "$1" 2>/dev/null | grep -Fq 'install ok installed'; then
#         local pkgtype=installation
#         if [[ -n $2 ]]; then
#             local target=$2
#         else
#             local target=$1
#         fi

#         if [[ -e $target ]]; then
#             error "Unable to unpack '$1' (destination already exists)."
#             exit 1
#         fi

#         # unpack into tmpfolder
#         local tmpfolder=$(fakeroot -u dpkg-repack --generate "$1" 2>/dev/null | awk '{print $(NF-2)}')

#         # rename tmpfolder to target then clean up control file modified by dpkg-repack
#         mv "$tmpfolder" "$target" 2>/dev/null && \
#         sed -i 's/ .$//;/ (Repackaged on .* by dpkg-repack.)/d' "$target/DEBIAN/control" 2>/dev/null
#     else
#         if [[ -n $1 ]]; then
#             error "'$1' is not an installed package or valid debian archive"
#         else
#             error "You have not supplied a package to unpack"
#         fi
#         exit 1
#     fi

#     # check for target directory and exit now if missing
#     if [[ ! -d $target ]]; then
#         error "Failed to generate folder '$target' for '$1'"
#         exit 1
#     fi

#     echo "Successfully unpacked $pkgtype to: $target"

#     # prompt to delete archive
#     if [[ $pkgtype = archive && $auto != enabled ]]; then
#         read -p "Remove '$1'? "
#         if [[ ${REPLY,} = y* ]]; then
#             rm "$1"
#         fi
#     fi
# }

usage(){
    cat <<-EOF
	Usage: ${0##*/} OPTION ARCHIVE|DIRECTORY|PACKAGE TARGET
	Manipulate debian archives.

	Mandatory Options
	  -b, --build           create a debian archive from DIR
	  -c, --combo           download then unpack PKG(s)
	  -d, --download        download PKGS(s) via apt-get
	  -r, --reinst          reinstall ARCHIVE(s)
	  -s, --show            show PKG(s) available for download
	  -u, --unpack          unpack ARCHIVE or installed PKG into DIR

	Miscellaneous Options
	  -a, --auto            skip any prompts for user input
	  -f, --show-format     format output of --show

	Some mandatory options may be compined. This includes --download and --unpack (equivalent --combo) as well as --build and --reinst.

	NOTE: ARCHIVE refers to a '.deb' debian archive. PKG refers to program available to download or an installed program to unpack.
	EOF
    exit 0
}

warning(){
    echo "${script}:WARNING: $@" >&2
}


script=${0##*/}

if (( $# == 1 )) && [[ $1 =~ ^(-h|--help|help)$ ]]; then
    usage
fi

shopts='a,b,c,d,f,r,s,u'
lopts='auto,build,combo,download,reinst,show,show-format,unpack'

params=$(getopt -o "$shopts" -l "$lopts" -n "$script" -- "$@")

if (( $? != 0 )); then
    exit 1
fi

eval set -- "$params"

while true; do
    case "$1" in
        -a|--auto)
            auto='enabled'
            shift
            ;;
        -b|--build)
            cmds+=('build')
            shift
            ;;
        -c|--combo)
            cmds+=('combo')
            shift
            ;;
        -d|--download)
            cmds+=('download')
            shift
            ;;
        -f|--show-format)
            format='enabled'
            shift
            ;;
        -r|--reinst)
            cmds+=('reinst')
            shift
            ;;
        -s|--show)
            cmds+=('show')
            shift
            ;;
        -u|--unpack)
            cmds+=('unpack')
            shift
            ;;
        --)
            shift
            break
            ;;
    esac
done

if (( $# == 0 )); then
    echo "$script: missing operand" >&2
    echo "Try '$script' for more information." >&2
    exit 1
elif (( ${#cmds[@]} == 0 )); then
    echo "$script: missing mandatory option" >&2
    echo "Try '$script' for more information." >&2
    exit 1
elif (( ${#cmds[@]} == 1 )); then
    cmd=${cmds[0]}
elif (( ${#cmds[@]} == 2 )) && [[ "${cmds[@]}" = *download* && "${cmds[@]}" = *unpack* ]]; then
    cmd='combo'
elif (( ${#cmds[@]} == 2 )) && [[ "${cmds[@]}" = *build* && "${cmds[@]}" = *reinst* ]]; then
    cmd='build'
    reinstall='true'
else
    error "Too many commands"
    exit 1
fi

eval "$cmd" "$@"
