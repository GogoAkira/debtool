#!/bin/bash
#
# Simple tool to facilitate downloading and repacking debian archives


# enable auto option
auto(){
    AUTO=1
}

# create a debian archive from a directory
build(){
    (
        # NOTE: child functions inherit the parent's environment (to include local)...
        #       consider declaring locals if they will only be used by subdirs

        if [[ ! -d $1 ]]; then
            error "'$1' is not a directory"
            exit 1
        fi

        prep_build "$1"

        if [[ -n $2 ]]; then
            ARCHIVE=$2
        else

            # identify control file
            control=$1/DEBIAN/control

            # verify control file (regular file, readable, nonzero size)
            if [[ ! -f $control || ! -r $control || ! -s $control ]]; then
                error "Missing or invalid control file '$control'"
                exit 1
            fi

            # determine archive name from contents of control file
            ARCHIVE=$(awk '/^Package: / { p=$2 }; /^Version: / { v=$2 }; /^Architecture: / { a=$2 }; END{ if ( length(p) == 0 || length(v) == 0 ) exit; if ( length(a) > 0 ) { printf "%s_%s_%s.deb", p, v, a } else { printf "%s_%s.deb", p, v } }' "$control" 2>/dev/null)

            # verify control file was parsed
            if [[ -z $ARCHIVE ]]; then
                error "Unparsable control file '$control'"
                exit 1
            fi
        fi

        check_build_destination "$1" "$ARCHIVE"

        # build the archive
        # fakeroot dpkg-deb --build "${1%/}" "$ARCHIVE"
        fakeroot dpkg-deb --build "$1" "$ARCHIVE"

        # check if build failed
        if (( $? != 0 )); then
            error "dpkg-deb exited with a nonzero exit code"
            restore_backup
            exit 1
        fi

        # check if archive was created and handle backup
        if [[ -f $ARCHIVE ]]; then
            remove_backup
        else
            restore_backup
            exit 1
        fi

        if (( REINSTALL == 1 )); then
            reinst "$ARCHIVE"
        fi
    )
}

# # create a debian archive from a directory
# build(){

#     if [[ -d $1 ]]; then
#         prep_build "$1"

#         if [[ -n $2 ]]; then
#             ARCHIVE=$2
#         else

#             # identify archive control file
#             control=$1/DEBIAN/control

#             # confirm existence of archive control
#             if [[ ! -f $control || ! -r $control || ! -s $control ]]; then
#                 error "'$1' is missing control file"
#                 exit 1
#             fi

#             # determine archive name from contents of control file
#             ARCHIVE=$(awk '/^Package: / { p=$2 }; /^Version: / { v=$2 }; /^Architecture: / { a=$2 }; END{ if ( length(a) > 0 ) { printf "%s_%s_%s.deb", p, v, a } else { printf "%s_%s.deb", p, v } }' "$control")

#         fi

#         check_build_destination "$1" "$ARCHIVE"

#         # build the archive
#         # fakeroot dpkg-deb --build "${1%/}" "$ARCHIVE"
#         fakeroot dpkg-deb --build "$1" "$ARCHIVE"

#         # check if build failed
#         if (( $? != 0 )); then
#             error "dpkg-deb exited with a nonzero exit code"
#             restore_backup
#             exit 1
#         fi

#         # check if archive was created and handle backup
#         if [[ -f $ARCHIVE ]]; then
#             remove_backup
#         else
#             restore_backup
#             exit 1
#         fi

#         if (( REINSTALL == 1 )); then
#             reinst "$ARCHIVE"
#         fi
#     else
#         if [[ -n $1 ]]; then
#             error "'$1' is not a directory"
#         else
#             error "You have not supplied a directory"
#         fi
#         exit 1
#     fi

# }

# ensure build destination does not already exist
check_build_destination(){
    if [[ -e $2 && -f $2 ]]; then
        if (( AUTO != 1 )); then

            # prompt to overwrite pre-existing file
            read -p "Overwrite pre-existing file '$2' (y|N)? "
            if [[ ${REPLY,} != y* ]]; then
                exit 1
            fi

        else
            warning "Overwriting pre-existing file '$2'"
        fi

        create_backup "$@"

    elif [[ -e $2 ]]; then
        error "Unable to build '$1' (destination '$2' already exists but is not a file)"
        exit 1
    fi
}

# check dependencies for prescribed command
check_dependency(){
    (
        # store dependencies for each function
        declare -A d
        d['build']='awk dpkg fakeroot find gzip xargs'
        d['combo']='apt awk dpkg'
        d['download']='awk apt'
        d['reinst']='dpkg'
        d['show']='awk apt'
        d['unpack']='awk dpkg'
        d['unpack_installation']='dpkg-repack fakeroot sed'

        # get the dependencies for function $1
        depends=${d["$1"]}

        missing=()
        for program in $depends; do
            hash "$program" &>/dev/null || missing+=("$program")
        done

        if (( ${#missing[@]} > 0 )); then
            echo "Please install the following program(s) before continuing: ${missing[@]}"
            return 1
        fi
    ) || exit 1
}

# check for Internet connectivity
check_internet(){
    ping -c1 -W1 4.2.2.2 &>/dev/null || ping -c1 -W1 8.8.8.8 &>/dev/null
}

# ensure unpack destination does not already exist
check_unpack_destination(){
    if [[ -e $2 ]]; then
        error "Unable to unpack '$1' (destination folder '$2' already exists)"
        exit 1
    fi
}

# # download package(s) via apt-get then unpack
# combo(){

#     auto
#     local z

#     for package in "$@"; do

#         # wipe local variables
#         local destination= fullpath= output=

#         # sets $destination and $fullpackage
#         findpackage "$package"

#         # confirm apt-get was able to determing package destination filename
#         if [[ -z $destination || -z $fullpackage ]]; then
#             error "Failed to identify '$package' for download"
#             z=1
#             continue
#         fi

#         # store output from apt-get to determine if a download occurred

#         # NOTE: We are using apt-get to download even if $destination already
#         #       exists because apt-get is intelligent and will only
#         #       re-download if neccesary (i.e. file checksum mismatch).

#         output=$(apt-get --quiet download "$fullpackage" 2>/dev/null)

#         # confirm apt-get exited successfully
#         if (( $? != 0 )); then
#             error "apt-get experienced an error downloading '$package'"
#             check_internet || warning "No Internet connectivity"
#             z=1
#             continue
#         # confirm download exists
#         elif [[ ! -f $destination ]]; then
#             error "Failed to download '$package'"
#             z=1
#             continue
#         fi

#         # unpack downloaded archive
#         if [[ -n $output ]]; then
#             unpack "$destination"
#         # prompt to unpack pre-existing archive (if auto is not enabled)
#         elif (( AUTO != 1 )); then
#             read -p "Would you like to unpack pre-existing archive '$destination'? "
#             if [[ ${REPLY,} = y* ]]; then
#                 unpack "$destination"
#             fi
#         # skip prompt (if auto is enabled)
#         else
#             echo "Skipping unpack of pre-existing archive '$destination'"
#         fi

#         z=$?
#     done

#     return "$z"
# }

# download package(s) via apt-get then unpack
# combo(){
#     auto
#     for package in "$@"; do
#         combo_worker "$package"
#     done
# }

# download package(s) via apt-get then unpack
combo(){
    auto

    for package in "$@"; do
        (
            # wipe local variables
            # local destination= fullpackage= output=

            # sets $destination and $fullpackage
            findpackage "$package"

            # confirm apt-get was able to determing package destination filename
            if [[ -z $destination || -z $fullpackage ]]; then
                error "Failed to identify '$package' for download"
                return 1
            fi

            # store output from apt-get to determine if a download occurred

            # NOTE: We are using apt-get to download even if $destination already
            #       exists because apt-get is intelligent and will only
            #       re-download if neccesary (i.e. file checksum mismatch).

            output=$(apt-get --quiet download "$fullpackage" 2>/dev/null)

            # confirm apt-get exited successfully
            if (( $? != 0 )); then
                error "apt-get experienced an error downloading '$package'"
                check_internet || warning "No Internet connectivity"
                return 1
            # confirm download exists
            elif [[ ! -f $destination ]]; then
                error "Failed to download '$package'"
                return 1
            fi

            # unpack downloaded archive
            if [[ -n $output ]]; then
                unpack "$destination"
            # prompt to unpack pre-existing archive (if auto is not enabled)
            elif (( AUTO != 1 )); then
                read -p "Would you like to unpack pre-existing archive '$destination'? "
                if [[ ${REPLY,} = y* ]]; then
                    unpack "$destination"
                fi
            # skip prompt (if auto is enabled)
            else
                echo "Skipping unpack of pre-existing archive '$destination'"
            fi
        )
    done
}


# combo_worker(){
#     # wipe local variables
#     local destination= fullackage= output=

#     # sets $destination and $fullpackage
#     findpackage "$1"

#     # confirm apt-get was able to determing package destination filename
#     if [[ -z $destination || -z $fullpackage ]]; then
#         error "Failed to identify '$1' for download"
#         return 1
#     fi

#     # store output from apt-get to determine if a download occurred

#     # NOTE: We are using apt-get to download even if $destination already
#     #       exists because apt-get is intelligent and will only
#     #       re-download if neccesary (i.e. file checksum mismatch).

#     output=$(apt-get --quiet download "$fullpackage" 2>/dev/null)

#     # confirm apt-get exited successfully
#     if (( $? != 0 )); then
#         error "apt-get experienced an error downloading '$1'"
#         check_internet || warning "No Internet connectivity"
#         return 1
#     # confirm download exists
#     elif [[ ! -f $destination ]]; then
#         error "Failed to download '$1'"
#         return 1
#     fi

#     # unpack downloaded archive
#     if [[ -n $output ]]; then
#         unpack "$destination"
#     # prompt to unpack pre-existing archive (if auto is not enabled)
#     elif (( AUTO != 1 )); then
#         read -p "Would you like to unpack pre-existing archive '$destination'? "
#         if [[ ${REPLY,} = y* ]]; then
#             unpack "$destination"
#         fi
#     # skip prompt (if auto is enabled)
#     else
#         echo "Skipping unpack of pre-existing archive '$destination'"
#     fi
# }

# backup a pre-existing archive (into a temp dir)
create_backup(){

    # create a temporary directory
    BACKUPDIR=$(mktemp --directory 2>/dev/null)
    if [[ ! -d $BACKUPDIR ]]; then
        error "Experienced unknown error while creating temporary directory"
        echo "Please remove the pre-existing file and try again"
        exit 1
    fi

    # backup pre-existing file
    mv "$2" "$BACKUPDIR"

    if [[ -f $BACKUPDIR/${2##*/} ]]; then
        BACKUPFILE=$BACKUPDIR/${2##*/}
        info "Storing backup of '$2' at '$BACKUPFILE'"
    else
        info "Failed to backup '$2'"
    fi

}

# # backup a pre-existing archive (into the same dir)
# create_backup(){
#     if [[ ! -e "${2}~" ]]; then
#         mv "$2" "${2}~"
#         if [[ -f "${2}~" ]]; then
#             info "Created backup of '$2'"
#             backup='true'
#         else
#             info "Failed to backup '$2'"
#             error "Please remove '$2' before retrying"
#             exit 1
#         fi
#     fi
# }

# download package(s) via apt-get
download(){

    local successes
    local failures

    for package in "$@"; do
        if apt-get download "$package" &>/dev/null; then
            successes+=("$package")
        else
            failures+=("$package")
        fi
    done

    if (( ${#successes[@]} > 0 )); then
        echo "Successfully downloaded: ${successes[@]}"
    fi

    if (( ${#failures[@]} > 0 )); then
        error "Failed to download: ${failures[@]}"
        check_internet || warning "No Internet connectivity"
        return 1
    fi
}

error(){
    echo "${script}:ERROR: $@" >&2
}

# enable format option
format(){
    FORMAT=1
}

info(){
    echo "$PROGRAM:INFO: $@"
}

# determing package type (archive, installation, neither, or both)
pkgtype(){
    local pkgtype=()

    # for a debian archive file
    dpkg-deb --info "$1" &>/dev/null && pkgtype+=(archive)

    # for an installed package
    dpkg-query --show --showformat='${Status}' "$1" 2>/dev/null | grep -Fq 'install ok installed' && pkgtype+=(installation)

    if (( ${#pkgtype[@]} == 0 )); then
        error "'$1' is not an installed package or valid debian archive"
        return 1
    elif (( ${#pkgtype[@]} == 1 )); then
        echo "${pkgtype[0]}"
    elif (( ${#pkgtype[@]} == 2 )); then
        warning "'$1' is both an installed package and a debian archive (assuming you are referring to the debian archive)"
        echo archive
    fi
}

# prepare directory prior to build
prep_build(){
    (
        # enter directory
        cd "$1"

        # prepare manpages (verify write access, set perms, compress)
        while IFS= read -rd $'\0' manpage; do
            if [[ ! -w $manpage ]]; then
                error "No write access to '$manpage'"
                return 1
            elif ! chmod 0644 "$manpage"; then
                error "Failed to chmod '$manpage'"
                return 1
            elif ! gzip -9fn "$manpage" ; then
                error "Failed to gzip '$manpage'"
                return 1
            fi
        done < <(find -type f -regex '\./usr/share/man/.*' -name '*.[1-9]' ! -name '*.gz' -print0)

        # update md5sums if necessary
        if [[ -f DEBIAN/md5sums ]]; then

            # verify write access
            if [[ ! -w DEBIAN/md5sums ]]; then
                error "No write access to 'DEBIAN/md5sums'"
                return 1
            elif ! prep_md5sums; then
                error "Failed to update DEBIAN/md5sums"
                return 1
            elif ! md5sum --check --status DEBIAN/md5sums; then
                error "DEBIAN/md5sums failed checksum verification"
                return 1
            fi

        fi
    ) || exit 1
}

# remake md5sums using original as a template
prep_md5sums(){
    mv "DEBIAN/md5sums" "DEBIAN/md5sums~" &&
    awk '{printf "%s\0", $2}' "DEBIAN/md5sums~" \
    | xargs -0r md5sum > DEBIAN/md5sums &&
    rm "DEBIAN/md5sums~" &&
    chmod 644 "DEBIAN/md5sums"
}

# enable quiet option
quiet(){
    QUIET='>/dev/null'
}

# reinstall package(s)
reinst(){

    for archive in "$@"; do

        # confirm archive is a file
        if [[ ! -f $archive ]]; then
            error "'$archive' does not appear to be a valid file"
            continue
        fi

        # lookup package name in archive control file
        package=$(dpkg-deb -f "$archive" package 2>/dev/null)

        # confirm lookup of package name was successful
        if [[ -z $package ]]; then
            error "'$archive' does not appear to be a valid debian archive"
            continue
        fi

        # if sudo apt-get purge "$package" &>/dev/null; then
        if sudo dpkg --purge "$package" &>/dev/null; then
            echo "dpkg: purged '$package'"
        else
            echo "dpkg: failed to purge '$package' (perhaps it was not installed)"
        fi

        if sudo dpkg --install "$archive" &>/dev/null; then
            echo "dpkg: installed '$package' ($archive)"
        else
            echo "dpkg: failed to install '$package' ($archive)"
        fi

    done

}

# remove an archive backup (from a temp dir)
remove_backup(){
    if [[ -n $BACKUPFILE ]]; then
        rm "$BACKUPFILE"
        rmdir "$BACKUPDIR"
    fi
}

# # remove an archive backup (from the same dir)
# remove_backup(){
#     if [[ -f "${archive}~" && $backup = 'true' ]]; then
#         rm "${archive}~"
#         if [[ -f "${archive}~" ]]; then
#             info "Failed to remove backup file '${archive}~'"
#         else
#             info "Removed backup file '${archive}~'"
#         fi
#     fi
# }

# restore an archive backup (from a temp dir)
restore_backup(){
    if [[ -n $BACKUPFILE ]]; then
        mv -T "$BACKUPFILE" "$ARCHIVE"
        if [[ -f $ARCHIVE ]]; then
            info "Restored '$ARCHIVE' from backup"
        else
            info "Failed to restore '$ARCHIVE' from backup"
        fi
        rmdir "$BACKUPDIR"
    fi
}

# restore an archived backup (from the same dir)
# restore_backup(){
#     if [[ -f "${archive}~" && $backup = 'true' ]]; then
#         mv "${archive}~" "$archive"
#         if [[ -f $archive ]]; then
#             info "Restored '$archive' from backup"
#         else
#             info "Failed to restore '$archive' from backup"
#         fi
#     fi
# }

# show packages available for download
show(){

    # set the output format string
    if (( FORMAT == 1 )); then
        local printFULL='printf "apt-get download %s:%s=%s\n", p, a, v'
        local printBRIEF='printf "apt-get download %s=%s\n", p, v'
    else
        local printFULL='print p, v, a'
        local printBRIEF='print p, v'
    fi

        if (( $? != 0 )) || [[ -z $results ]]; then
            error "apt-cache is unable to locate package '$package'"
            continue
        else
            echo "$results"
        fi

    done
}

# unpack a debian archive or installed package
unpack(){

    # determine package type (debian archive or installed) and exit if neither
    pkgtype=$(pkgtype "$1") || exit 1

    if [[ $pkgtype = archive ]]; then

        if [[ -n $2 ]]; then
            local target=$2
        else
            local target=$(dpkg-deb --field "$1" package version architecture | awk '{print $2}' | paste -sd_)
        fi

        check_unpack_destination "$1" "$target"

        # unpack archive
        dpkg-deb --raw-extract "$1" "$target"
    elif [[ $pkgtype = installation ]]; then
        if [[ -n $2 ]]; then
            local target=$2
        else
            local target=$1
        fi

        check_unpack_destination "$1" "$target"

        # unpack into tmpfolder
        local tmpfolder=$(fakeroot -u dpkg-repack --generate "$1" 2>/dev/null | awk '{print $(NF-2)}')

        # rename tmpfolder to target then clean up control file modified by dpkg-repack
        mv "$tmpfolder" "$target" &>/dev/null \
        && sed -i 's/ .$//;/ (Repackaged on .* by dpkg-repack.)/d' "$target/DEBIAN/control" &>/dev/null
    fi

    # check for target directory and exit now if missing
    if [[ ! -d $target ]]; then
        error "Failed to generate folder '$target' for '$1'"
        return 1
    fi

    echo "Successfully unpacked $pkgtype to: $target"

    # prompt to delete archive
    if [[ $pkgtype = archive ]] && (( AUTO != 1 )); then
        read -p "Remove '$1'? "
        if [[ ${REPLY,} = y* ]]; then
            rm "$1"
        fi
    fi
}

# # unpack a debian archive or installed package
# unpack(){
#     # for a debian archive file
#     if dpkg-deb --info "$1" &>/dev/null; then
#         local pkgtype=archive
#         if [[ -n $2 ]]; then
#             local target=$2
#         else
#             local target=$(dpkg-deb --field "$1" package version architecture | awk '{print $2}' | paste -sd_)
#         fi

#         if [[ -e $target ]]; then
#             error "Unable to unpack '$1' (destination already exists)."
#             exit 1
#         fi

#         # unpack archive
#         dpkg-deb --raw-extract "$1" "$target"

#     # for an installed package
#     elif dpkg-query --show --showformat='${Status}' "$1" 2>/dev/null | grep -Fq 'install ok installed'; then
#         local pkgtype=installation
#         if [[ -n $2 ]]; then
#             local target=$2
#         else
#             local target=$1
#         fi

#         if [[ -e $target ]]; then
#             error "Unable to unpack '$1' (destination already exists)."
#             exit 1
#         fi

#         # unpack into tmpfolder
#         local tmpfolder=$(fakeroot -u dpkg-repack --generate "$1" 2>/dev/null | awk '{print $(NF-2)}')

#         # rename tmpfolder to target then clean up control file modified by dpkg-repack
#         mv "$tmpfolder" "$target" 2>/dev/null && \
#         sed -i 's/ .$//;/ (Repackaged on .* by dpkg-repack.)/d' "$target/DEBIAN/control" 2>/dev/null
#     else
#         if [[ -n $1 ]]; then
#             error "'$1' is not an installed package or valid debian archive"
#         else
#             error "You have not supplied a package to unpack"
#         fi
#         exit 1
#     fi

#     # check for target directory and exit now if missing
#     if [[ ! -d $target ]]; then
#         error "Failed to generate folder '$target' for '$1'"
#         exit 1
#     fi

#     echo "Successfully unpacked $pkgtype to: $target"

#     # prompt to delete archive
#     if [[ $pkgtype = archive && $auto != enabled ]]; then
#         read -p "Remove '$1'? "
#         if [[ ${REPLY,} = y* ]]; then
#             rm "$1"
#         fi
#     fi
# }

usage(){
    cat <<-EOF
	Usage: $PROGRAM OPTION ARCHIVE|DIRECTORY|PACKAGE TARGET
	Manipulate debian archives.

	Mandatory Options
	  -b, --build           create a debian archive from DIR
	  -d, --download        download PKGS(s) via apt-get
	  -r, --reinst          reinstall ARCHIVE(s)
	  -s, --show            show PKG(s) available for download
	  -u, --unpack          unpack ARCHIVE or installed PKG into DIR

	Combination Options
	  -c, --combo           download then unpack PKG(s) [-du]
	  -z, --fast            build fast [-abr]

	Miscellaneous Options
	  -a, --auto            skip any prompts for user input
	  -f, --show-format     format output of --show
	  -q, --quiet           suppress normal messages

	Some mandatory options may be combined. Combination options include '--auto --download --unpack' (equivalent --combo), '--auto --build --reinst --quiet' (equivalent to --fast), and '--build --reinst'.

	NOTE: ARCHIVE refers to a '.deb' debian archive. PKG refers to program available to download or an installed program to unpack.
	EOF
    exit 0
}

warning(){
    echo "$PROGRAM:WARNING: $@" >&2
}


PROGRAM=${0##*/}

if (( $# == 1 )) && [[ $1 =~ ^(-h|--help|help)$ ]]; then
    usage
fi

shopts='a,b,c,d,f,q,r,s,u,z'
lopts='auto,build,combo,download,fast,quiet,reinst,show,show-format,unpack'

params=$(getopt -o "$shopts" -l "$lopts" -n "$PROGRAM" -- "$@") || exit 1

eval set -- "$params"

while true; do
    case "$1" in
        -a|--auto)
            auto
            shift
            ;;
        -b|--build)
            cmds+=('build')
            shift
            ;;
        -c|--combo)
            auto
            cmds+=('combo')
            shift
            ;;
        -d|--download)
            cmds+=('download')
            shift
            ;;
        -f|--show-format)
            format
            shift
            ;;
        -q|--quiet)
            quiet
            shift
            ;;
        -r|--reinst)
            cmds+=('reinst')
            shift
            ;;
        -s|--show)
            cmds+=('show')
            shift
            ;;
        -u|--unpack)
            cmds+=('unpack')
            shift
            ;;
        -z|--fast)
            auto
            quiet
            cmds+=('build')
            cmds+=('reinst')
            shift
            ;;
        --)
            shift
            break
            ;;
    esac
done

if (( ${#cmds[@]} == 0 )); then
    echo "$PROGRAM: missing mandatory option" >&2
    echo "Try '$PROGRAM --help' for more information." >&2
    exit 1
elif (( $# == 0 )); then
    echo "$PROGRAM: missing operand" >&2
    echo "Try '$PROGRAM --help' for more information." >&2
    exit 1
elif (( ${#cmds[@]} == 1 )); then
    cmd=${cmds[0]}
elif (( ${#cmds[@]} == 2 )) && [[ "${cmds[@]}" = *download* && "${cmds[@]}" = *unpack* ]]; then
    cmd='combo'
elif (( ${#cmds[@]} == 2 )) && [[ "${cmds[@]}" = *build* && "${cmds[@]}" = *reinst* ]]; then
    cmd='build'
    REINSTALL=1
else
    error "Too many commands"
    exit 1
fi

check_dependency "$cmd"

eval -- "$cmd" "$@" "$QUIET"
