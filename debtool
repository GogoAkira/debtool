#!/bin/bash
#
# Simple tool to facilitate downloading and repacking debian archives


# create a debian archive from a directory
build(){
    if [[ -d $1 ]]; then
        prep "$1"

        if [[ -n $2 ]]; then
            local archive=$2
        else
            # generate archive name from control file
            control=$1/DEBIAN/control
            if [[ ! -f $control || ! -r $control || ! -s $control ]]; then
                error "'$1' is missing control file"
                exit 1
            fi
            local package=$(grep -oP '(?<=Package: ).+' "$control")
            local version=$(grep -oP '(?<=Version: ).+' "$control")
            local arch=$(grep -oP '(?<=Architecture: ).+' "$control")
            local archive=${package}_${version}_${arch}.deb
        fi

        # build the archive
        fakeroot dpkg-deb --build "${1%/}" "$archive"
    else
        if [[ -n $1 ]]; then
            error "'$1' is not a directory"
        else
            error "You have not supplied a directory"
        fi
        exit 1
    fi
}

# download package(s) via apt-get then unpack
combo(){
    for package in "$@"; do

        # generate pre-download directory listing
        local pre=$(find -maxdepth 1 -type f -iname '*.deb' -printf '%C@ %p\n')

        download "$package"

        # generate post-download directory listing
        local post=$(find -maxdepth 1 -type f -iname '*.deb' -printf '%C@ %p\n')

        # identify additional files
        local dirdiff=$(grep -Fxvf <(echo "$pre") <(echo "$post") | cut -d' ' -f2)

        # count additional files
        if [[ -n $dirdiff ]]; then
            local filecount=$(wc -l <<<"$dirdiff")
        else
            local filecount=0
        fi

        # did not identify a download (can occur if archive already exists)
        if (( filecount == 0 )); then
            error "There do not appear to be any newly downloaded packages."

            # attempt to identify pre-existing archive by name
            local plausible=$(find -maxdepth 1 -type f -name "${package}*.deb" 2>/dev/null)

            # count pre-existing archives
            if [[ -n $plausible ]]; then
                local plauscount=$(wc -l <<<"$plausible")
            else
                local plauscount=0
            fi

            # prompt for installation of pre-existing archive
            if (( plauscount == 1 )); then
                read -p "Would you like to unpack pre-existing archive '$plausible'? "
                if [[ ${REPLY,} = y ]]; then
                    unpack "$plausible"
                fi
            else
                exit 1
            fi
        # identified a download (desired behavior)
        elif (( filecount == 1 )); then
            unpack "$dirdiff"
        # detected multiple downloads (should not happen)
        elif (( filecount >= 2 )); then
            error "There appear to be multiple downloaded package."
            exit 1
        fi

    done
}

# download package(s) via apt-get
download(){
    local successes
    local failures
    for package in "$@"; do
        if apt-get download "$package" &>/dev/null; then
            successes+=("$package")
        else
            failures+=("$package")
        fi
    done

    if (( ${#successes[@]} > 0 )); then
        echo "Successfully downloaded: ${successes[@]}"
    fi

    if (( ${#failures[@]} > 0 )); then
        echo "Failed to download: ${failures[@]}"
        exit 1
    fi
}

error(){
    echo "ERROR: $@" >&2
}

# prepare directory prior to build
prep(){
    (
    # enter directory
    cd "$1"

    # compress manpages (if necessary)
    # find -type f -regex '\./usr/share/man/.*' -name '*.[1-9]' ! -name '*.gz' -print0 | xargs -0r gzip -9fn

    # verify write access then compress manpages (if necessary)
    while IFS= read -rd $'\0' manpage; do
        if [[ -w $manpage ]]; then
            gzip -9fn "$manpage"
        else
            error "No write access to '$manpage'"
            return 1
        fi
    done < <(find -type f -regex '\./usr/share/man/.*' -name '*.[1-9]' ! -name '*.gz' -print0)

    # update md5sums if necessary
    if [[ -f DEBIAN/md5sums ]]; then

        # verify write access
        if [[ -w DEBIAN/md5sums ]]; then

            # disregard original and generate new md5sums
            # find -type f ! -regex '\./DEBIAN/.*' ! -regex '\./etc/.*' -printf '%P\0' | LC_ALL=C sort -z | xargs -0r md5sum > DEBIAN/md5sums

            # use original md5sums as a template
            (mv "DEBIAN/md5sums" "DEBIAN/md5sums~" && \
            awk '{printf "%s\0", $2}' "DEBIAN/md5sums~" | xargs -0r md5sum > DEBIAN/md5sums && \
            rm "DEBIAN/md5sums~" && \
            chmod 644 "DEBIAN/md5sums") 2>/dev/null
        else
            error "No write access to 'DEBIAN/md5sum'"
            return 1
        fi
    fi

    ) || exit 1
}

# unpack a debian archive or installed package
unpack(){
    # for a debian archive file
    if dpkg-deb --info "$1" &>/dev/null; then
        local pkgtype=archive
        if [[ -n $2 ]]; then
            local target=$2
        else
            local target=${1%.*}
        fi

        if [[ -e $target ]]; then
            error "Unable to unpack '$1' (destination already exists)."
            exit 1
        fi

        dpkg-deb --raw-extract "$1" "$target"
    # for an installed package
    elif dpkg-query --status "$1" 2>/dev/null | grep -q '^Status: install ok installed$'; then
        local pkgtype=installation
        if [[ -n $2 ]]; then
            local target=$2
        else
            local target=$1
        fi

        if [[ -e $target ]]; then
            error "Unable to unpack '$1' (destination already exists)."
            exit 1
        fi

        # unpack into tmpfolder
        local tmpfolder=$(fakeroot -u dpkg-repack --generate "$1" 2>/dev/null | awk '{print $(NF-2)}')

        # rename tmpfolder to target then clean up control file modified by dpkg-repack
        mv "$tmpfolder" "$target" 2>/dev/null && \
        sed -i 's/ .$//;/ (Repackaged on .* by dpkg-repack.)/d' "$target/DEBIAN/control" 2>/dev/null
    else
        if [[ -n $1 ]]; then
            error "'$1' is not an installed package or valid debian archive"
        else
            error "You have not supplied a package to unpack"
        fi
        exit 1
    fi

    # check for target directory and exit now if missing
    if [[ ! -d $target ]]; then
        error "Failed to generate folder '$target' for '$1'"
        exit 1
    fi

    echo "Successfully unpacked $pkgtype to: $target"

    # prompt to delete archive
    if [[ $pkgtype = archive ]]; then
        read -p "Remove '$1'? "
        if [[ ${REPLY,} = y ]]; then
            rm "$1"
        fi
    fi
}


if (( $# == 0 )); then
    error "Missing operand"
    echo "Try 'chmod --help' for more information." >&2
    exit 1
elif (( $# == 1 )) && [[ $1 =~ ^(-h|--help|help)$ ]]; then
    echo "Usage: ${0##*/} OPTION [ARCHIVE|DIRECTORY|PACKAGE] [TARGET]"
    echo "Manipulate debian archives."
    echo
    echo "  -b, --build           create a debian archive from DIR"
    echo "  -c, --combo           download then unpack PKG(s)"
    echo "  -d, --download        download PKGS(s) via apt-get"
    echo "  -u, --unpack          unpack ARCHIVE or installed PKG into DIR"
    echo
    echo "NOTE: ARCHIVE refers to a '.deb' debian archive. PKG refers to" \
         "program available to download or an installed program to unpack."
    exit 0
elif [[ $1 =~ ^(-b|--build)$ ]]; then
    build "${@:2}"
elif [[ $1 =~ ^(-c|--combo)$ ]]; then
    combo "${@:2}"
elif [[ $1 =~ ^(-d|--download)$ ]]; then
    download "${@:2}"
elif [[ $1 =~ ^(-u|--unpack)$ ]]; then
    unpack "${@:2}"
else
    error "Invalid option"
    exit 1
fi
