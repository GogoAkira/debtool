#!/bin/bash
#
# Simple tool to facilitate downloading and repacking debian archives


# create a debian archive from a directory
build(){
    if [[ -d $1 ]]; then
        prep "$1"

        if [[ -n $2 ]]; then
            local archive=$2
        else

            # identify archive control file
            control=$1/DEBIAN/control

            # confirm existence of archive control
            if [[ ! -f $control || ! -r $control || ! -s $control ]]; then
                error "'$1' is missing control file"
                exit 1
            fi

            # determine archive name from contents of control file
            local archive=$(awk '/^Package: / { p=$2 }; /^Version: / { v=$2 }; /^Architecture: / { a=$2 }; END{ if ( length(a) > 0 ) { printf "%s_%s_%s.deb", p, v, a } else { printf "%s_%s.deb", p, v } }' "$control")

        fi

        # build the archive
        fakeroot dpkg-deb --build "${1%/}" "$archive"
    else
        if [[ -n $1 ]]; then
            error "'$1' is not a directory"
        else
            error "You have not supplied a directory"
        fi
        exit 1
    fi
}

# download package(s) via apt-get then unpack
combo(){
    for package in "$@"; do

        # aquire the package destination filename

        # NOTE: apt-get will output nothing if package exists in the
        #       current directory, hence the need to cd out if. This
        #       is quite hackish but the alternative would be manually
        #       parsing `apt-cache show "$package"`.

        local dest=$(cd / && apt-get --print-uris download "$package" 2>/dev/null | awk '{print $2}')

        # confirm apt-get was able to determing package destination filename
        if (( $? != 0 )) || [[ -z $dest ]]; then
            error "Failed to identify '$package' for download"
            continue
        fi

        # store apt-get output log to determing if download occurred

        # NOTE: We are using apt-get to download even if $dest already
        #       exists because apt-get is intelligent and will only
        #       re-download if neccesary (i.e. file checksum mismatch).

        local output=$(apt-get --quiet download "$package" 2>/dev/null)

        # confirm apt-get exited successfully
        if (( $? != 0 )); then
            error "apt-get experienced an error downloading '$package'"
            continue
        # confirm download exists
        elif [[ ! -f $dest ]]; then
            error "Failed to download '$package'"
            continue
        fi

        # unpack downloaded package
        if [[ -n $output ]]; then
            unpack "$dest"
        # prompt to unpack pre-existing package
        else
            read -p "Would you like to unpack pre-existing archive '$dest'? "
            if [[ ${REPLY,} = y ]]; then
                unpack "$dest"
            fi
        fi

    done
}

# download package(s) via apt-get
download(){
    local successes
    local failures
    for package in "$@"; do
        if apt-get download "$package" &>/dev/null; then
            successes+=("$package")
        else
            failures+=("$package")
        fi
    done

    if (( ${#successes[@]} > 0 )); then
        echo "Successfully downloaded: ${successes[@]}"
    fi

    if (( ${#failures[@]} > 0 )); then
        echo "Failed to download: ${failures[@]}"
        exit 1
    fi
}

error(){
    echo "ERROR: $@" >&2
}

# prepare directory prior to build
prep(){
    (
    # enter directory
    cd "$1"

    # compress manpages (if necessary)
    # find -type f -regex '\./usr/share/man/.*' -name '*.[1-9]' ! -name '*.gz' -print0 | xargs -0r gzip -9fn

    # verify write access then compress manpages (if necessary)
    while IFS= read -rd $'\0' manpage; do
        if [[ -w $manpage ]]; then
            chmod 0644 "$manpage"
            gzip -9fn "$manpage"
        else
            error "No write access to '$manpage'"
            return 1
        fi
    done < <(find -type f -regex '\./usr/share/man/.*' -name '*.[1-9]' ! -name '*.gz' -print0)

    # update md5sums if necessary
    if [[ -f DEBIAN/md5sums ]]; then

        # verify write access
        if [[ -w DEBIAN/md5sums ]]; then

            # disregard original and generate new md5sums
            # find -type f ! -regex '\./DEBIAN/.*' ! -regex '\./etc/.*' -printf '%P\0' | LC_ALL=C sort -z | xargs -0r md5sum > DEBIAN/md5sums

            # use original md5sums as a template
            (mv "DEBIAN/md5sums" "DEBIAN/md5sums~" && \
            awk '{printf "%s\0", $2}' "DEBIAN/md5sums~" | xargs -0r md5sum > DEBIAN/md5sums && \
            rm "DEBIAN/md5sums~" && \
            chmod 644 "DEBIAN/md5sums") 2>/dev/null
        else
            error "No write access to 'DEBIAN/md5sum'"
            return 1
        fi
    fi

    ) || exit 1
}

# unpack a debian archive or installed package
unpack(){
    # for a debian archive file
    if dpkg-deb --info "$1" &>/dev/null; then
        local pkgtype=archive
        if [[ -n $2 ]]; then
            local target=$2
        else
            local target=${1%.*}
        fi

        if [[ -e $target ]]; then
            error "Unable to unpack '$1' (destination already exists)."
            exit 1
        fi

        # unpack archive
        dpkg-deb --raw-extract "$1" "$target"

    # for an installed package
    elif dpkg-query --show --showformat='${Status}' "$1" 2>/dev/null | grep -Fq 'install ok installed'; then
        local pkgtype=installation
        if [[ -n $2 ]]; then
            local target=$2
        else
            local target=$1
        fi

        if [[ -e $target ]]; then
            error "Unable to unpack '$1' (destination already exists)."
            exit 1
        fi

        # unpack into tmpfolder
        local tmpfolder=$(fakeroot -u dpkg-repack --generate "$1" 2>/dev/null | awk '{print $(NF-2)}')

        # rename tmpfolder to target then clean up control file modified by dpkg-repack
        mv "$tmpfolder" "$target" 2>/dev/null && \
        sed -i 's/ .$//;/ (Repackaged on .* by dpkg-repack.)/d' "$target/DEBIAN/control" 2>/dev/null
    else
        if [[ -n $1 ]]; then
            error "'$1' is not an installed package or valid debian archive"
        else
            error "You have not supplied a package to unpack"
        fi
        exit 1
    fi

    # check for target directory and exit now if missing
    if [[ ! -d $target ]]; then
        error "Failed to generate folder '$target' for '$1'"
        exit 1
    fi

    echo "Successfully unpacked $pkgtype to: $target"

    # prompt to delete archive
    if [[ $pkgtype = archive ]]; then
        read -p "Remove '$1'? "
        if [[ ${REPLY,} = y ]]; then
            rm "$1"
        fi
    fi
}


if (( $# == 0 )); then
    error "Missing operand"
    echo "Try 'chmod --help' for more information." >&2
    exit 1
elif (( $# == 1 )) && [[ $1 =~ ^(-h|--help|help)$ ]]; then
    echo "Usage: ${0##*/} OPTION [ARCHIVE|DIRECTORY|PACKAGE] [TARGET]"
    echo "Manipulate debian archives."
    echo
    echo "  -b, --build           create a debian archive from DIR"
    echo "  -c, --combo           download then unpack PKG(s)"
    echo "  -d, --download        download PKGS(s) via apt-get"
    echo "  -u, --unpack          unpack ARCHIVE or installed PKG into DIR"
    echo
    echo "NOTE: ARCHIVE refers to a '.deb' debian archive. PKG refers to" \
         "program available to download or an installed program to unpack."
    exit 0
else
    parameters=$(getopt -o b,c,d,u -l build,combo,download,unpack -n "${0##*/}" -- "$@")
    eval set -- "$parameters"

    while true; do
        case "$1" in
            -b|--build)
                cmd='build'
                shift
                ;;
            -c|--combo)
                cmd='combo'
                shift
                ;;
            -d|--download)
                cmd='download'
                shift
                ;;
            -u|--unpack)
                cmd='unpack'
                shift
                ;;
            --)
                shift
                break
                ;;
        esac
    done

    case "$cmd" in
        build)
            build "$@"
            ;;
        combo)
            combo "$@"
            ;;
        download)
            download "$@"
            ;;
        unpack)
            unpack "$@"
            ;;
    esac
fi

# if (( $# == 0 )); then
#     error "Missing operand"
#     echo "Try 'chmod --help' for more information." >&2
#     exit 1
# elif (( $# == 1 )) && [[ $1 =~ ^(-h|--help|help)$ ]]; then
#     echo "Usage: ${0##*/} OPTION [ARCHIVE|DIRECTORY|PACKAGE] [TARGET]"
#     echo "Manipulate debian archives."
#     echo
#     echo "  -b, --build           create a debian archive from DIR"
#     echo "  -c, --combo           download then unpack PKG(s)"
#     echo "  -d, --download        download PKGS(s) via apt-get"
#     echo "  -u, --unpack          unpack ARCHIVE or installed PKG into DIR"
#     echo
#     echo "NOTE: ARCHIVE refers to a '.deb' debian archive. PKG refers to" \
#          "program available to download or an installed program to unpack."
#     exit 0
# elif [[ $1 =~ ^(-b|--build)$ ]]; then
#     build "${@:2}"
# elif [[ $1 =~ ^(-c|--combo)$ ]]; then
#     combo "${@:2}"
# elif [[ $1 =~ ^(-d|--download)$ ]]; then
#     download "${@:2}"
# elif [[ $1 =~ ^(-u|--unpack)$ ]]; then
#     unpack "${@:2}"
# else
#     error "Invalid option"
#     exit 1
# fi

# elif [[ $1 =~ ^(-b|--build)$ ]]; then
#     build "${@:2}"
# elif [[ $1 =~ ^(-c|--combo)$ ]]; then
#     combo "${@:2}"
# elif [[ $1 =~ ^(-d|--download)$ ]]; then
#     download "${@:2}"
# elif [[ $1 =~ ^(-u|--unpack)$ ]]; then
#     unpack "${@:2}"
# else
#     error "Invalid option"
#     exit 1
# fi
