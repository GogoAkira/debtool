#!/bin/bash
#
# Simple tool to facilitate downloading and repacking debian archives


# create a debian archive from a directory
build(){
    (
        # NOTE: child functions inherit the parent's environment (to include local)...
        #       consider declaring locals if they will only be used by subdirs

        if [[ ! -d $1 ]]; then
            error "'$1' is not a directory"
            exit 1
        fi

        prep_build "$1"

        if [[ -n $2 ]]; then
            ARCHIVE=$2
        else

            # identify control file
            control=$1/DEBIAN/control

            # verify control file (regular file, readable, nonzero size)
            if [[ ! -f $control || ! -r $control || ! -s $control ]]; then
                error "Missing or invalid control file '$control'"
                exit 1
            fi

            # determine archive name from contents of control file
            ARCHIVE=$(awk '/^Package: / { p=$2 }; /^Version: / { v=$2 }; /^Architecture: / { a=$2 }; END{ if ( length(p) == 0 || length(v) == 0 ) exit; if ( length(a) > 0 ) { printf "%s_%s_%s.deb", p, v, a } else { printf "%s_%s.deb", p, v } }' "$control" 2>/dev/null)

            # verify control file was parsed
            if [[ -z $ARCHIVE ]]; then
                error "Unparsable control file '$control'"
                exit 1
            fi
        fi

        check_build_destination "$1" "$ARCHIVE"

        # build the archive
        fakeroot dpkg-deb --build "$1" "$ARCHIVE"

        # check if build failed
        if (( $? != 0 )); then
            error "dpkg-deb exited with a nonzero exit code"
            restore_backup
            exit 1
        fi

        # check if archive was created and handle backup
        if [[ -f $ARCHIVE ]]; then
            remove_backup
        else
            restore_backup
            exit 1
        fi

        if (( REINSTALL == 1 )); then
            reinst "$ARCHIVE"
        fi
    )
}


# ensure build destination does not already exist
check_build_destination(){
    if [[ -e $2 && -f $2 ]]; then
        if (( AUTO != 1 )); then

            # prompt to overwrite pre-existing file
            read -p "Overwrite pre-existing file '$2' (y|N)? "
            if [[ ${REPLY,} != y* ]]; then
                exit 1
            fi

        else
            warning "Overwriting pre-existing file '$2'"
        fi

        create_backup "$@"

    elif [[ -e $2 ]]; then
        error "Unable to build '$1' (destination '$2' already exists but is not a file)"
        exit 1
    fi
}


# check dependencies for prescribed function
check_dependency(){

    (
        # store dependencies for each function
        declare -A dlist
        dlist['build']='awk dpkg fakeroot find gzip xargs'
        dlist['combo']='apt awk dpkg'  # show + unpack
        dlist['download']='apt awk'
        dlist['interactive']='apt awk'  # download + show
        dlist['reinst']='dpkg'
        dlist['show']='apt awk'
        dlist['unpack']='awk dpkg'
        dlist['unpack_installation']='dpkg-repack fakeroot sed'

        # get the dependencies for function $1
        dependencies=(${dlist["$1"]})

        missing=()
        for program in "${dependencies[@]}"; do
            hash "$program" &>/dev/null || missing+=("$program")
        done

        if (( ${#missing[@]} > 0 )); then
            echo "Please install the following program(s) before continuing: ${missing[@]}" >&2
            return 1
        fi
    ) || exit 1
}


# check for Internet connectivity
check_internet(){
    ping -c1 -W1 4.2.2.2 &>/dev/null || ping -c1 -W1 8.8.8.8 &>/dev/null
}


# ensure unpack destination does not already exist
check_unpack_destination(){
    if [[ -e $2 ]]; then
        error "Unable to unpack '$1' (destination folder '$2' already exists)"
        exit 1
    fi
}


# download package(s) via apt-get then unpack
combo(){
    enable_auto

    local package

    for package in "$@"; do
        (
            # sets $DESTINATION and $FULLPACKAGE
            findpackage "$package"

            # confirm apt-get was able to determing package destination filename
            if [[ -z $DESTINATION || -z $FULLPACKAGE ]]; then
                error "Failed to identify '$package' for download"
                return 1
            fi

            # store output from apt-get to determine if a download occurred

            # NOTE: We are using apt-get to download even if $DESTINATION file
            #       already exists because apt-get is intelligent and will only
            #       re-download if neccesary (i.e. file checksum mismatch).

            output=$(apt-get --quiet download "$FULLPACKAGE" 2>/dev/null)

            # confirm apt-get exited successfully
            if (( $? != 0 )); then
                error "apt-get experienced an error downloading '$package'"
                check_internet || warning "No Internet connectivity"
                return 100
            # confirm download exists
            elif [[ ! -f $DESTINATION ]]; then
                error "Failed to download '$package'"
                return 1
            fi

            # unpack downloaded archive
            if [[ -n $output ]]; then
                unpack "$DESTINATION"
            else
                echo "Skipping unpack of pre-existing archive '$DESTINATION'"
            fi
        )

    # exit if there was a connectivity error
    if (( $? == 100 )); then
        exit 1
    fi

    done
}


# backup a pre-existing archive (into a temp dir)
create_backup(){

    # create a temporary directory
    BACKUPDIR=$(mktemp --directory 2>/dev/null)
    if [[ ! -d $BACKUPDIR ]]; then
        error "Experienced unknown error while creating temporary directory"
        echo "Please remove the pre-existing file and try again"
        exit 1
    fi

    # backup pre-existing file
    mv "$2" "$BACKUPDIR"

    if [[ -f $BACKUPDIR/${2##*/} ]]; then
        BACKUPFILE=$BACKUPDIR/${2##*/}
        info "Storing backup of '$2' at '$BACKUPFILE'"
    else
        info "Failed to backup '$2'"
    fi

}


# download package(s) via apt-get
download(){
    (
        for package in "$@"; do

            # download best package version available
            while IFS= read -r string; do
                if apt-get download "$string" &>/dev/null; then
                    successes+=("$package")
                    continue 2
                fi
            done < <("$PROGRAM" --show --format "$package" 2>/dev/null | awk '{print $NF}')

            # this point is only reachable upon failure
            failures+=("$package")

        done

        if (( ${#successes[@]} > 0 )); then
            info "Successfully downloaded: ${successes[@]}"
        fi

        if (( ${#failures[@]} > 0 )); then
            error "Failed to download: ${failures[@]}"
            check_internet || warning "No Internet connectivity"
            return 1
        fi
    )
}


# enable auto option
enable_auto(){
    AUTO=1
}


# enable format option
enable_format(){
    FORMAT=1
}


# enable option to create new md5sums
enable_md5sums(){
    MD5SUMS=1
}


# enable quiet option
enable_quiet(){
    QUIET='>/dev/null'
}


# enable reinstall option
enable_reinstall(){
    REINSTALL=1
}

error(){
    echo "$PROGRAM:ERROR: $@" >&2
}


fast(){
    enable_auto
    enable_quiet
    enable_reinstall

    local directory

    for directory in "$@"; do
        build "$directory"
    done
}


# aquire the package destination filename
findpackage(){

    # NOTE: apt-get will output nothing if package exists in the
    #       current directory, hence the need to cd out if. This
    #       is quite hackish but the alternative would be manually
    #       parsing `apt-cache show "$package"`.

    local tempdir=$(mktemp --directory 2>/dev/null)

    while IFS= read -r string; do
        destination=$(cd "$tempdir" && apt-get --print-uris download "$string" 2>/dev/null | awk '{print $2}')
        if [[ -n $destination ]]; then
            fullpackage=$string
            break
        fi
    done < <("$PROGRAM" --show --format "$1" 2>/dev/null | awk '{print $NF}')

    rmdir "$tempdir" &>/dev/null
}

# enable format option
format(){
    FORMAT=1
}

info(){
    echo "$PROGRAM:INFO: $@"
}

# download a package interactively
interactive(){
    if (( $# > 1 )); then
        error "Too many arguments"
        exit 1
    fi

    (
        readarray -t packages < <("$PROGRAM" --show --format "$1" | awk '{print $NF}')

        select choice in "${packages[@]}" EXIT; do
            if [[ -z $choice ]]; then
                error "Invalid selection"
                continue
            elif [[ $choice = EXIT ]]; then
                exit 1
            fi

            "$PROGRAM" --download "$choice" && return 0
        done
    )
}

# enable option to create new md5sums
md5(){
    MD5=1
}

# make md5sums from scratch
md5sums_make(){

    mv 'DEBIAN/md5sums' 'DEBIAN/md5sums~' &>/dev/null

    find -type f ! -path '*/DEBIAN/*' -printf '%P\0' | LC_ALL=C sort -z | xargs -0r -- md5sum > DEBIAN/md5sums

    # get file size
    local size=$(stat --format=%s 'DEBIAN/md5sums' 2>/dev/null)

    # ensure file is not empty (use string comparison)
    [[ $size = 0 ]] && rm 'DEBIAN/md5sums'

    if [[ -f DEBIAN/md5sums ]]; then
        rm 'DEBIAN/md5sums~' &>/dev/null
        chmod 644 'DEBIAN/md5sums'
        return 0
    else
        return 1
    fi

}

# remake md5sums using original as a template
md5sums_remake(){
    mv 'DEBIAN/md5sums' 'DEBIAN/md5sums~' &&
    awk '{printf "%s\0", $2}' 'DEBIAN/md5sums~' \
    | xargs -0r md5sum > DEBIAN/md5sums &&
    rm 'DEBIAN/md5sums~' &&
    chmod 644 'DEBIAN/md5sums'
}

# determing package type (archive, installation, neither, or both)
pkgtype(){
    (
        # for a debian archive file
        dpkg-deb --info "$1" &>/dev/null && pkgtype+=('archive')

        # for an installed package
        [[ $(dpkg-query --show --showformat="\${Status}" "$1" 2>/dev/null) = 'install ok installed' ]] && pkgtype+=('installation')

        if (( ${#pkgtype[@]} == 0 )); then
            error "'$1' is not an installed package or valid debian archive"
            return 1
        elif (( ${#pkgtype[@]} == 1 )); then
            echo "${pkgtype[0]}"
        elif (( ${#pkgtype[@]} == 2 )); then
            warning "'$1' is an installed package and a debian archive (assuming you intended the debian archive)"
            echo archive
        fi
    )
}

# prepare directory prior to build
prep_build(){
    (
        # enter directory
        cd "$1"

        # prepare manpages (verify write access, set perms, compress)
        while IFS= read -rd $'\0' manpage; do
            if [[ ! -w $manpage ]]; then
                error "No write access to '$manpage'"
                return 1
            elif ! chmod 0644 "$manpage"; then
                error "Failed to chmod '$manpage'"
                return 1
            elif ! gzip -9fn "$manpage" ; then
                error "Failed to gzip '$manpage'"
                return 1
            fi
        done < <(find -type f -regex '\./usr/share/man/.*' -name '*.[1-9]' ! -name '*.gz' -print0)

        # update md5sums if necessary
        if [[ -f DEBIAN/md5sums ]]; then

            # verify write access
            if [[ ! -w DEBIAN/md5sums ]]; then
                error "No write access to 'DEBIAN/md5sums'"
                return 1
            elif (( MD5 == 1 )) && ! md5sums_make; then
                error "Failed to create DEBIAN/md5sums"
                return 1
            elif (( MD5 != 1 )) && ! md5sums_remake; then
                error "Failed to update DEBIAN/md5sums"
                return 1
            elif ! md5sum --check --status DEBIAN/md5sums; then
                error "DEBIAN/md5sums failed checksum verification"
                return 1
            fi

        fi
    ) || exit 1
}

# enable quiet option
quiet(){
    QUIET='>/dev/null'
}

# # reinstall package(s)
# reinst(){

#     local z

#     for archive in "$@"; do

#         # confirm archive is a file
#         if [[ ! -f $ARCHIVE ]]; then
#             error "'$ARCHIVE' does not appear to be a valid file"
#             z=1
#             continue
#         fi

#         # lookup package name in archive control file
#         local package=$(dpkg-deb -f "$ARCHIVE" package 2>/dev/null)

#         # confirm lookup of package name was successful
#         if [[ -z $package ]]; then
#             error "'$ARCHIVE' does not appear to be a valid debian archive"
#             z=1
#             continue
#         fi

#         # if sudo apt-get purge "$package" &>/dev/null; then
#         if sudo dpkg --purge "$package" &>/dev/null; then
#             echo "dpkg: purged '$package'"
#         else
#             echo "dpkg: failed to purge '$package' (perhaps it was not installed)"
#         fi

#         if sudo dpkg --install "$ARCHIVE" &>/dev/null; then
#             echo "dpkg: installed '$package' ($ARCHIVE)"
#             z=0
#         else
#             echo "dpkg: failed to install '$package' ($ARCHIVE)"
#             z=1
#         fi

#     done

#     return "$z"
# }

# reinstall package(s)
reinst(){

    # reinstall each package within a subshell (no need for local or unset)
    for archive in "$@"; do
        (
            # confirm archive is a file
            if [[ ! -f $archive ]]; then
                error "'$archive' does not appear to be a valid file"
                return 1
            fi

            # lookup package name in archive control file
            package=$(dpkg-deb -f "$archive" package 2>/dev/null)

            # confirm lookup of package name was successful
            if [[ -z $package ]]; then
                error "'$archive' does not appear to be a valid debian archive"
                return 1
            fi

            # if sudo apt-get purge "$package" &>/dev/null; then
            if sudo dpkg --purge "$package" &>/dev/null; then
                echo "dpkg: purged '$package'"
            else
                echo "dpkg: failed to purge '$package' (perhaps it was not installed)"
            fi

            if sudo dpkg --install "$archive" &>/dev/null; then
                echo "dpkg: installed '$package' ($archive)"
            else
                echo "dpkg: failed to install '$package' ($archive)"
                return 1
            fi
        )
    done

}

# remove an archive backup (from a temp dir)
remove_backup(){
    if [[ -n $BACKUPFILE ]]; then
        rm "$BACKUPFILE"
        rmdir "$BACKUPDIR"
    fi
}

# restore an archive backup (from a temp dir)
restore_backup(){
    if [[ -n $BACKUPFILE ]]; then
        mv -T "$BACKUPFILE" "$ARCHIVE"
        if [[ -f $ARCHIVE ]]; then
            info "Restored '$ARCHIVE' from backup"
        else
            info "Failed to restore '$ARCHIVE' from backup"
        fi
        rmdir "$BACKUPDIR"
    fi
}

# show packages available for download
show(){

    # set the output format string
    if (( FORMAT == 1 )); then
        local printFULL='printf "apt-get download %s:%s=%s\n", p, a, v'
        local printBRIEF='printf "apt-get download %s=%s\n", p, v'
    else
        local printFULL='print p, v, a'
        local printBRIEF='print p, v'
    fi

    # show each package details within a subshell (no need for local or unset)
    for package in "$@"; do
        (
            set -o pipefail

            # parse APT's package cache for the package in question
            apt-cache show "$package" 2>/dev/null | awk "/^Package: /{p=\$2} /^Version: /{v=\$2} /^Architecture/{a=\$2} /^$/{ if (a==\"all\") { $printBRIEF } else { $printFULL } }" || \
            {
                error "apt-cache is unable to locate package '$package'"
                return 1
            }
        )
    done
}

# show_worker(){
#     (
#         set -o pipefail

#         # parse APT's package cache for the package in question
#         apt-cache show "$1" 2>/dev/null | awk "/^Package: /{p=\$2} /^Version: /{v=\$2} /^Architecture/{a=\$2} /^$/{ if (a==\"all\") { $printBRIEF } else { $printFULL } }" || \
#         {
#             error "apt-cache is unable to locate package '$1'"
#             return 1
#         }
#     )
# }

# unpack a debian archive or installed package
unpack(){

    # determine package type (debian archive or installed) and exit if neither
    local pkgtype=$(pkgtype "$1") || return 1

    if [[ $pkgtype = archive ]]; then

        if [[ -n $2 ]]; then
            # set target to supplied argument
            local target=$2
        else
            # set target from parsed control file
            local target=$(dpkg-deb --field "$1" package version architecture | awk '{print $2}' | paste -sd_)
        fi

        check_unpack_destination "$1" "$target"

        # unpack archive
        dpkg-deb --raw-extract "$1" "$target"

    elif [[ $pkgtype = installation ]]; then

        # perform additional dependency check
        check_dependency unpack_installation

        if [[ -n $2 ]]; then
            # set target to supplied argument
            local target=$2
        else
            # set target to program's name
            local target=$1
        fi

        check_unpack_destination "$1" "$target"

        # unpack into tmpfolder
        local tmpfolder=$(fakeroot -u dpkg-repack --generate "$1" 2>/dev/null | awk '{print $(NF-2)}')

        # rename tmpfolder to target then clean up control file modified by dpkg-repack
        mv "$tmpfolder" "$target" &>/dev/null \
        && sed -i 's/ .$//;/ (Repackaged on .* by dpkg-repack.)/d' "$target/DEBIAN/control" &>/dev/null
    fi

    # check for target directory and exit now if missing
    if [[ ! -d $target ]]; then
        error "Failed to generate folder '$target' for '$1'"
        return 1
    fi

    echo "Successfully unpacked $pkgtype to: $target"

    # prompt to delete archive
    if [[ $pkgtype = archive ]] && (( AUTO != 1 )); then
        read -p "Remove '$1'? "
        if [[ ${REPLY,} = y* ]]; then
            rm "$1"
        fi
    fi
}

usage(){
    cat <<-EOF
	Usage: $PROGRAM OPTION ARCHIVE|DIRECTORY|PACKAGE TARGET
	Manipulate debian archives.

	Mandatory Options
	  -b, --build           create a debian archive from DIR
	  -d, --download        download PKGS(s) via apt-get
	  -i, --interactive     download PKG interactively (select specific version)
	  -r, --reinst          reinstall ARCHIVE(s)
	  -s, --show            show PKG(s) available for download
	  -u, --unpack          unpack ARCHIVE or installed PKG into DIR

	Combination Options
	  -c, --combo           download and unpack PKG(s) [-du]
	  -z, --fast            build and reinstall DIR(s) [-abr]

	Miscellaneous Options
	  -a, --auto            skip prompts for user input
	  -f, --format          format output of --show for manual download
	  -m, --md5sums         generate new md5sums (otherwise rebuild original)
	  -q, --quiet           suppress normal output

	Some mandatory options may be combined. Combination options include '--auto --download --unpack' (equivalent --combo), '--auto --build --reinst --quiet' (equivalent to --fast), and '--build --reinst'.

	NOTE: ARCHIVE refers to a '.deb' debian archive. PKG refers to program available to download or an installed program to unpack.
	EOF
    exit 0
}

warning(){
    echo "$PROGRAM:WARNING: $@" >&2
}


PROGRAM=${0##*/}
VERSION='0.1.0'

if (( $# == 1 )) && [[ $1 =~ ^(-h|--help|help)$ ]]; then
    usage
fi

shopts='a,b,c,d,f,i,m,q,r,s,u,v,z'
lopts='auto,build,combo,download,fast,format,interactive,md5sums,quiet,reinst,show,unpack,version'

params=$(getopt -o "$shopts" -l "$lopts" -n "$PROGRAM" -- "$@") || exit 1

eval set -- "$params"

while true; do
    case "$1" in
        -a|--auto)
            enable_auto
            shift
            ;;
        -b|--build)
            cmds+=('build')
            shift
            ;;
        -c|--combo)
            cmds+=('combo')
            shift
            ;;
        -d|--download)
            cmds+=('download')
            shift
            ;;
        -f|--format)
            enable_format
            shift
            ;;
        -i|--interactive)
            cmds+=('interactive')
            shift
            ;;
        -m|--md5sums)
            enable_md5sums
            shift
            ;;
        -q|--quiet)
            enable_quiet
            shift
            ;;
        -r|--reinst)
            cmds+=('reinst')
            shift
            ;;
        -s|--show)
            cmds+=('show')
            shift
            ;;
        -u|--unpack)
            cmds+=('unpack')
            shift
            ;;
        -v|--version)
            echo "$PROGRAM $VERSION"
            echo
            echo "Author: Brian Beffa <brbsix@gmail.com>"
            echo "Copyright © 2015"
            exit 0
            ;;
        -z|--fast)
            cmds+=('fast')
            shift
            ;;
        --)
            shift
            break
            ;;
    esac
done

if (( ${#cmds[@]} == 0 )); then
    echo "$PROGRAM: missing mandatory option" >&2
    echo "Try '$PROGRAM --help' for more information." >&2
    exit 1
elif (( $# == 0 )); then
    echo "$PROGRAM: missing operand" >&2
    echo "Try '$PROGRAM --help' for more information." >&2
    exit 1
elif (( ${#cmds[@]} == 1 )); then
    cmd=${cmds[0]}
elif (( ${#cmds[@]} == 2 )) && [[ "${cmds[@]}" = *download* && "${cmds[@]}" = *unpack* ]]; then
    cmd='combo'
elif (( ${#cmds[@]} == 2 )) && [[ "${cmds[@]}" = *build* && "${cmds[@]}" = *reinst* ]]; then
    enable_reinstall
    cmd='build'
else
    error "Too many commands"
    exit 1
fi

check_dependency "$cmd"

eval -- "$cmd" "$@" "$QUIET"
